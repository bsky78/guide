分支管理

分支在实际中有什么用呢？

假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。


在repository仓库中的每一个commit版本，串联起来就是一条时间线
然而在这条线上有一个默认的主分支master,这条主分支指向版本库
HEAD指向当前分支，如果指向master,而master指向某一个提交版本，那么工作的这个版本就是当前版本

HEAD --指向--> master  --指向--> 提交 

每次提交，master分支都会向前移动一步



当我们创建分支的时候，如dev,相当于在Git新建了一个指针叫dev,指向master相同的提交，再把Head指向dev，就表示当前分支在dev上：
Head  --指向--> dev --指向master相同的提交-->  提交

现在如果再dev 上commit后，dev指针向前移动，master原地不变


当我们在dev开发完成时，需要与master合并，方法是直接把master指向dev的当前提交就行了

合并完成后可以删除dev分支了,其实就是删除dev指针，最后剩下master这条分支了



命令：
创建dev分支：
$ git checkout -b dev
-b参数表示创建并切换，相当于两条命令
$ git branch dev
$ git checkout dev

查看当前分支
$ git branch
命令会列出所有分支，当前分支前面有 * 号


在dev上修改后commit，切换回master分支，将dev修改的内容合并到master分支上
$ git merge dev

git merge命令用于合并指定分支到当前分支
注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

合并完成后，就可以放心地删除dev分支了：
$ git branch -d dev
删除后，查看branch，就只剩下master分支了：
$ git branch



合并分支并补是一帆风顺的：冲突Conflict
操作出现冲突：两个分支master和m2 ,在m2分支上修改并提交文件a,然后切换回master分支上修改并提交文件a,这时候合并就产生冲突了
$ git merge m2

冲突需要手动打开冲突文件解决

查看冲突的文件
$ git status

Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容

























